
# Сайт: PicoCTF
# Автор: LT 'syreal' Jones
# Название: GDB Baby Step 2
# Сложность: Medium

Приступаем ко второму заданию из серии `GDB Baby Step`. Данное задание практически ничем не отличается от предыдущего.
Также необходимо разобраться, что же лежит в регистре `eax`.

#### Статический анализ. 

Проведем статический анализ скачанного бинарного файла. <br />

![image](https://github.com/user-attachments/assets/0c09b5fe-fd22-47d5-9643-6cc9e11ac288)

Данном блоке, происходит инициализация переменных и безусловный переход на метку `loc_401136`. Далее видим обычный цикл `for`. <br />
![image](https://github.com/user-attachments/assets/31e0fb22-11d9-4565-97f6-bfd25271d37a)

Исходя из этого переименнуем все переменные, чтобы глазу было поприятнее: <br />
![image](https://github.com/user-attachments/assets/e79e350e-41fc-4016-a1d1-24637bc7a71f)

Логика очень простая к переменной `ans` на каждой итерации будет прибавляться значение `i`, сам же цикл отрабатывает 607 раз (`0x25F`)
Получается, что в регистре `eax` будет получена сумма после того, как логика внутри `for` выполнится.

Посмотрим, по какому адресу лежит инструкция после `mov eax[rbp + ans]`. Видим, что это адрес `0x0000000000401141` на него и поставим точку останова.

#### Отладка.

Заходим в gdb. Порядок выполнения команд следующий: 
```gdb
b main
r
b *0x0000000000401141
c
p/d $eax
```

