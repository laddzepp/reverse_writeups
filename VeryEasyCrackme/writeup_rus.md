
# Сайт: crackmes.one
# Автор: __int2eh
# Название: VeryEasyCrackme
# Сложность: 1.3

Разберем очень легкое задание с сайта crackmes.one. Такой тип заданий является буквально
баяном, однако, в этот раз мы будем реверсить бинарный файл под Windows, так еще и с сообщениями на 
португальском языке =). В этом writeup'е без динамического анализа, так, как он здесь ни к чему. 
Защитного механизма как такового вообще нет, надо просто понять как работает алгоритм и все.

#### Решение.

Откроем файл в `IDA` и проанализируем алгоритм. <br />
![image](https://github.com/user-attachments/assets/638c6191-5ec1-48f1-958f-b61b45baf75b)

Сразу же видим, что в регистр `rax` кладется что-то похожее на строку в hex. Учитывая, что в x64 все строки представлятся в формате little-endian 
забросим в конвертор данное число, но в перевернутом виде. <br />
![image](https://github.com/user-attachments/assets/93df51e8-043a-4cd5-9a3a-808d660f40ac)

Далее начинаем анализировать цикл: <br />
![image](https://github.com/user-attachments/assets/f8d28a61-163f-4184-b284-bd56e9c1c5cc)

Здесь просто сравнивается переменная `i` с 7, значит цикл отработает 8 раз (так как нумерация идет с 0). И команда условного перехода `jle`, которая будет перебрасывать
исполнение в блок по метке `loc_401606`: <br />
![image](https://github.com/user-attachments/assets/865fb77d-51f7-4cac-861e-d2d3fc2a78aa)

Здесь логика очень простая каждый ascii-код "пароля" xor'ится с 0xA и записывается в в массив `xorOp`.

 Переходим к альтернативной ветке: <br />
 
![image](https://github.com/user-attachments/assets/54b672bf-1a03-4d2f-b822-3f152b97525c)

Этот блок кода приглашает пользователя ко вводу и выводит об этом в сообщении. Сам ввод осущетвляется с помощью функции `fgets`. Так, как функция fgets оставляет в конце введенной строки
знак перевода строки `\n`. Чтобы этого избежать автор программы решил использовать функцию `strcspn`, которая вычисляет длину строки, пока не встретила символ, который передается во втором аргументе.
Приведу ее профиль ниже: 

```c
size_t strcspn( const char *dest, const char *src );
```

Переходим ко второй части программы. Здесь также начинается цикл, который перебирает 8 символов строки, введенной пользователем и производит `xor` над этими символами. 

![image](https://github.com/user-attachments/assets/53d58507-3856-4f01-a7d1-3b5a84689838)

Далее два буфера в которых хранятся пароли сравниваются с помощью функции `memcmp` и если нам возвращается положительное число переходим в ветку с сообщением, что праоль верный. <br />
![image](https://github.com/user-attachments/assets/acc043db-b87c-408c-b089-bb2272eabfb5) <br />
![image](https://github.com/user-attachments/assets/99d56347-aaa7-4edf-b889-7985b473fd78) <br /> 


Соответственно просто вводим строку, которую нашли в начале, это и есть наш пароль: <br />
![image](https://github.com/user-attachments/assets/e0fc98ea-e7b7-4e8e-897b-fa4f1e0c112f)


