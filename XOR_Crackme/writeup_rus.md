# Сайт: https://crackmes.one/
# Название: XOR Crackme
# Автор: 2koy
# Сложность: 1


Разрберем достаточно простую задачу с сайта crackmes.one под названием XOR Crackme. Сайт предлагает достаточно большое кол-во задач 
на реверс, так, что заинтересует многих, кто интересуется этой темой. В отличии от таких сайтов, как 
forkbomb или picoCTF, на мой лично взгляд предлагает гораздо более приближенные к реальности задачи.
Задачи 3 и 4 уровня заставят покопаться уже даже бывалого реверсера :). 

Но хватит предисловий, давайте сразу к делу. Не будем церемониться со скаченным бинарником и закинем его сразу в IDA. 

#### Шаг 1. Отключение отладчика.

Хоть задача и простая, но сразу же нас встречает функция `isDebuggerPresent()`. Данная функция возвращает 0, если процесс выполняется
не под отладчиком и другое любое положительное число, если под ним. То есть, перед нами ничто иное, как простейший антиотладочный прием.

  ![image](https://github.com/user-attachments/assets/290bb77c-6301-46ae-b447-4b5451da8575)


Итак, пропатчим программу, чтобы обойти данный механизм.Для этого наводим на инструкцию, которую хотими изменить, далее идем в Edit -> Patch Program->Assemble.
И меняем инструкцию следующим образом:

![image](https://github.com/user-attachments/assets/d218a879-0aaf-4b93-927d-f232de82785e)


Нажимаем Ок. И как видим мы успешно пропатчили программу. 

![image](https://github.com/user-attachments/assets/dca3fa5b-972c-439b-9f8b-00aee0ff83f8)

В чем смысл данного действия ? Объсняю. Данный переход проверяет флаг ZF. До этого команда `test eax,eax` изменяла 
данный флаг на ZF = 1, флаг, естественно, не устанавливался, то есть ZF = 0  и соотвественно команда jz выкидывала нас в другую ветку, выдывая следующее сообщение:

![image](https://github.com/user-attachments/assets/5846a2b7-fdb4-4b2b-b513-241849d51bc5)

На этом патчинг не заканчивается, надо еще сохранить программу. Edit -> Patch Program -> Apply Patches. Обязательно делаем бэкап на случай, если что-то пойдет не так.

![image](https://github.com/user-attachments/assets/3c0ca7ce-220f-4e54-ad82-84fb2a802f48)

Все. Теперь можно посмотреть результат в отладчике. Сейчас мы должны безболезненно отлаживать программу. Для этого воспользуемся отладчиком x64dbg.
![image](https://github.com/user-attachments/assets/4a3f5e72-2c76-4640-ab31-230de6668e01)

Достигаем комады test, после того, как мы ее пройдем ZF должен остаться не установленным. Проверяем

![image](https://github.com/user-attachments/assets/b60cbc53-8d39-48fe-b5fe-396a918590b3)

![image](https://github.com/user-attachments/assets/767602d5-c815-4c5d-bd3d-84c7d6db00dd)

Отлично. Флаг остался неустановленным. А это значит, что мы переходим в нужную нам ветку.

![image](https://github.com/user-attachments/assets/b6570dfd-591c-4ef1-9745-ab2dd5cacc8c)

Как видим, мы действительно перешли на нужную нам ветку 

![image](https://github.com/user-attachments/assets/625c3516-c38e-40c3-8bc7-c7d502d3442a)


Итак, первый шаг на пути к решению задачи сделан. Теперь переходим к анализу другой части алгоритма.


#### Шаг 2. Анализ работы основного алгоритма.

Анализировать статически можно разными способами. Но первым шагом я обычно проверяю строки. Особенность строк в программе
заключается в том, что они никак не "перемалываются" компилятором. Соответственно, можно проверить, не валяется ли пароль 
где-то в программе, а также извлечь другую ценную информацию.

![image](https://github.com/user-attachments/assets/beacc29a-591f-475f-b9d2-a0c94ae67b9c)

Ну в целом, исходя из строк, становится понятно, что примерно делается в программе. Выводится отладочная информация связанная с хранением строки. 
Также мы имеем ограничение на длину строки. Но больше всего нас интересуют два сообщения `Correct password` и `Wrong Password`. Это наталкивает на мысль, что 
где-то в программе, есть разветвление алгоритма. Проверим эту теорию: 

![image](https://github.com/user-attachments/assets/918a0ab5-954d-43c6-95c6-a6db7db37256)

Как видим, все действительно так. Посмотрим на блок выше и увидим, что сравнивает введенные строки функции `memcmp`. Данная функция сравнивает побайтово два массива и будет продолжать работу, пока не встретится отличные от друг друга символы или не проверено n байт.



Теперь рассмотрим главный блок алгорима, здесь а начале функции производится приглашение ко вводу и ввод пароля, а также выполняется заполение какого-то Buf2 и непонятной 
переменной var_80. 

![image](https://github.com/user-attachments/assets/ee9f7a4a-ed97-497b-9c27-73956fed80c4)

Чтобы разобраться, что означает данная переменнная пройдем в стэк и увидим, что это наш массив Buf2, который просто напросто развалился. 

![image](https://github.com/user-attachments/assets/9b2af712-30ea-40ae-b3f1-a2a183015ff4)

Посмотрим в конец этого блока. IDA Pro распознала, что в регистр r8 кладется размер вводимой строчки и поставила рядом коментарий `;Size`. Но важно даже не это. А условие, что 
если размер введеной строки не совпадает с 0xB, то мы опять вылетаем в `Wrong Password`. 

![image](https://github.com/user-attachments/assets/6c7f318c-c5f0-4c8d-a745-7a26b82b2589)

Подредактируем переменную var_80. Для этого идем в стэк и указываем размер 11.

![image](https://github.com/user-attachments/assets/9b186700-827c-4a31-aa49-28828ad5878f)
![image](https://github.com/user-attachments/assets/02a8ea26-fb43-4a8a-810d-033cc44c9978) 

Теперь выглядит немного получше
![image](https://github.com/user-attachments/assets/7237b95a-449b-4e89-bc51-0b92dbb33d7a)


Помимо этого есть еще одна важная зацепка, обратите внимение на 
непонятные числа в шестнацатеричном формате. Данные числа означают коды ascii шестнацатеричном формате. Далее строка, в которую помещает пароль пользователь помещается 
в регистр rcx и передается в качестве аргумента функции sub_140001290. По этому пройдем в функцию sub_140001290 и посмотрим, что она делает.
Достаточно много ассемблерного кода, но автор задачи указал, что он использует xor шифрование, а это значит, что нам надо использовать поиск и найти строку где используется 
xor и регистр rcx, в котором, как изветсно лежит пользовательская строка.

![image](https://github.com/user-attachments/assets/5362f22e-b63b-4977-85aa-a6f353164665)

Отлично, мы нашли строку, которая xor'ит введенную строку с ключом 0x4B, что эквивалентно 'K'.
Осталось только расшифровать строку. Из того, что может являться символами у нас есть только `0x1B393E04`, `0x3C38382A`, `0x3924`, `0x2F`. По смещению в принципе становится понятно, что они располагаются в памяти друг за другом. Теперь возьмем простейший xor decrypt  и найдем пароль. Запишем их в обратном порядке, так как работает механизм little endian и строка получается написанной наоборот. 
![image](https://github.com/user-attachments/assets/b47fd49d-75e0-46fe-98ad-0466f58463c2)
Отлично, мы ввели значения из var_80 проксорили их с ключом 0x4B и получили, то с чем сравнивается Buf1. Теперь можно перевернуть строку с помощь python скрипта и пробовать вводить пароль. 
![image](https://github.com/user-attachments/assets/6933539b-40c1-4ee2-9f26-91dad8037bde)
Запустим программу и увидим, что мы верно расшифровали пароль.\
![image](https://github.com/user-attachments/assets/aa85b457-c5c3-4091-a6d1-0839539ceee4)

#### Вывод: 
Программа успешно "взломана"  и поставленная задача выполнена. 









 

