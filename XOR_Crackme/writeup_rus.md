# Сайт: https://crackmes.one/
# Название: XOR Crackme
# Автор: 2koy
# Сложность: 1


Разрберем достаточно простую задачу с сайта crackmes.one под названием XOR Crackme. Сайт предлагает достаточно большое кол-во задач 
на реверс, так, что заинтересует многих, кто интересуется этой темой. В отличии от таких сайтов, как 
forkbomb или picoCTF, на мой лично взгляд предлагает гораздо более приближенные к реальности задачи.
Задачи 3 и 4 уровня заставят покопаться уже даже бывалого реверсера :). 

Но хватит предисловий, давайте сразу к делу. Не будем церемониться со скаченным бинарником и закинем его сразу в IDA. 

#### Шаг 1. Отключение отладчика.

Хоть задача и простая, но сразу же нас встречает функция `isDebuggerPresent()`. Данная функция возвращает 0, если процесс выполняется
не под отладчиком и другое любое положительное число, если под ним. То есть, перед нами ничто иное, как простейший антиотладочный прием.

  ![image](https://github.com/user-attachments/assets/290bb77c-6301-46ae-b447-4b5451da8575)


Итак, пропатчим программу, чтобы обойти данный механизм.Для этого наводим на инструкцию, которую хотими изменить, далее идем в Edit -> Patch Program->Assemble.
И меняем инструкцию следующим образом:

![image](https://github.com/user-attachments/assets/d218a879-0aaf-4b93-927d-f232de82785e)


Нажимаем Ок. И как видим мы успешно пропатчили программу. 

![image](https://github.com/user-attachments/assets/dca3fa5b-972c-439b-9f8b-00aee0ff83f8)

В чем смысл данного действия ? Объсняю. Данный переход проверяет флаг ZF. До этого команда `test eax,eax` изменяла 
данный флаг на ZF = 1, флаг, естественно, не устанавливался, то есть ZF = 0  и соотвественно команда jz выкидывала нас в другую ветку, выдывая следующее сообщение:

![image](https://github.com/user-attachments/assets/5846a2b7-fdb4-4b2b-b513-241849d51bc5)

На этом патчинг не заканчивается, надо еще сохранить программу. Edit -> Patch Program -> Apply Patches. Обязательно делаем бэкап на случай, если что-то пойдет не так.

![image](https://github.com/user-attachments/assets/3c0ca7ce-220f-4e54-ad82-84fb2a802f48)

Все. Теперь можно посмотреть результат в отладчике. Сейчас мы должны безболезненно отлаживать программу. Для этого воспользуемся отладчиком x64dbg.
![image](https://github.com/user-attachments/assets/4a3f5e72-2c76-4640-ab31-230de6668e01)

Достигаем комады test, после того, как мы ее пройдем ZF должен остаться не установленным. Проверяем

![image](https://github.com/user-attachments/assets/b60cbc53-8d39-48fe-b5fe-396a918590b3)

![image](https://github.com/user-attachments/assets/767602d5-c815-4c5d-bd3d-84c7d6db00dd)

Отлично. Флаг остался неустановленным. А это значит, что мы переходим в нужную нам ветку.

![image](https://github.com/user-attachments/assets/b6570dfd-591c-4ef1-9745-ab2dd5cacc8c)

Как видим, мы действительно перешли на нужную нам ветку 

![image](https://github.com/user-attachments/assets/625c3516-c38e-40c3-8bc7-c7d502d3442a)


Итак, первый шаг на пути к решению задачи сделан. Теперь переходим к анализу другой части алгоритма.


#### Шаг 2. Анализ работы основного алгоритма.

Анализировать статически можно разными способами. Но первым шагом я обычно проверяю строки. Особенность строк в программе
заключается в том, что они никак не "перемалываются" компилятором. Соответсвенно, можно проверить, не валяется ли пароль 
где-то в программе, а также извлечь другую ценную инофрмацию. 








 

