# Сайт: picoCTF
# Название: keygenme
# Автор: LT 'syreal' Jones
# Сложность: Hard

Решим задачу уровня сложности hard с picoCTF, хотя на мой лично взгяд данной задаче скорее подходит уровень сложности Medium. Приступим к решению.
Первым делом проводим статический анализ бинарного файла. 

![image](https://github.com/user-attachments/assets/97f57ef9-e58a-4bb7-85d0-7fff6ce5185f)

В самом начале программы не происходит ничего сложного. Просто выводится приглашение ко вводу и реализуется ввод. Далее отрбабатывает загадочная функция 
`sub_1209`. После нее исполняется команда `test al, al` и выполняется проверка на установку флага ZF. Далее, в зависимости от ввода, переходим в одну из веток.
Посмотрим, что происходит в функции `sub_1209`.
![image](https://github.com/user-attachments/assets/3999dcce-a365-42b6-901f-2e33296b56d7) \
Сразу же бросаются в глаза символы представленные в виде hex. Напишем небольшой скрипт расшифровывающий строку.

```python
s1 = "7B4654436F636970"
s2 = "30795F676E317262"
s3 = "6B5F6E77305F7275"
s4 = "5F7933"
s5 = "7D"

s = s5 + s4 + s3 + s2 + s1
part_of_flag = bytearray.fromhex(s)
part_of_flag.reverse()
print(part_of_flag)
```

Увидим, следующую строчку `picoCTF{br1ng_y0ur_0wn_k3y_}`. Сразу же автор таска дает понять, что флаг неполный, поэтому продолжаем анализировать алгоритм. 
Далее генерируется хэш MD5 два раза. Данная функция берется из криптографической библеотеки `openssl`. Какие именно аргументы туда передаются, пока, что сказать трудно\
![image](https://github.com/user-attachments/assets/42870374-3a4a-4a63-b6ee-b1e68541da27)


Заглянем в документацию по openssl и найдем описание функции MD5. 

