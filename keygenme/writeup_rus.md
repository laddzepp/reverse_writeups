# Сайт: picoCTF
# Название: keygenme
# Автор: LT 'syreal' Jones
# Сложность: Hard

Решим задачу уровня сложности hard с picoCTF, хотя на мой лично взгяд данной задаче скорее подходит уровень сложности Medium. Приступим к решению.
Первым делом проводим статический анализ бинарного файла. 

#### Шаг 1. Статический анализ.

![image](https://github.com/user-attachments/assets/97f57ef9-e58a-4bb7-85d0-7fff6ce5185f)

В самом начале программы не происходит ничего сложного. Просто выводится приглашение ко вводу и реализуется ввод. Далее отрбабатывает загадочная функция 
`sub_1209`. После нее исполняется команда `test al, al` и выполняется проверка на установку флага ZF. Далее, в зависимости от ввода, переходим в одну из веток.
Посмотрим, что происходит в функции `sub_1209`.
![image](https://github.com/user-attachments/assets/3999dcce-a365-42b6-901f-2e33296b56d7) \
Сразу же бросаются в глаза символы представленные в виде hex. Напишем небольшой скрипт расшифровывающий строку.

```python
s1 = "7B4654436F636970"
s2 = "30795F676E317262"
s3 = "6B5F6E77305F7275"
s4 = "5F7933"
s5 = "7D"

s = s5 + s4 + s3 + s2 + s1
part_of_flag = bytearray.fromhex(s)
part_of_flag.reverse()
print(part_of_flag)
```

Увидим, следующую строчку `picoCTF{br1ng_y0ur_0wn_k3y_}`. Сразу же автор таска дает понять, что флаг неполный, поэтому продолжаем анализировать алгоритм. 
Далее генерируется хэш MD5 два раза. Данная функция берется из криптографической библеотеки `openssl`. Какие именно аргументы туда передаются, пока, что сказать трудно\
![image](https://github.com/user-attachments/assets/42870374-3a4a-4a63-b6ee-b1e68541da27)


Заглянем в документацию по openssl и найдем описание функции MD5. 

```c
unsigned char *MD5(const unsigned char *d, unsigned long n,
                 unsigned char *md);
```
Судя по описанию, функция принимает n байт, указатель на буфер d и указатель на буфер, где будет храниться md хэш.
Идем дальше. Остальные сведения получим на стадии отладки программы.

![image](https://github.com/user-attachments/assets/2882e03c-ada5-45be-9c02-c233bf1c64f3)

Видим цикл. Он логика внутри него отработает 15 раз. Следовательно  `var_C4` можно переименовать в `n`, а `var_C8` в `i`.
В блоке с логикой программы видим функцию `_sprintf`. Представим профиль данной функции ниже: 

```c
int sprintf(char *restrict str,
                   const char *restrict format, ...);
```

Данная функция является, как и `printf` вариадической. На месте троеточия она принимает любое кол-во аргументов. sprintf использутеся для записи некоторой строки в массив.
Получается, что в цикле, программа идет по некоторой строке и записывается символы в определенный буфер. Ровно такие же действия выполняются в цикле ниже

![image](https://github.com/user-attachments/assets/c35d6b86-7f3b-4d77-9f41-2a74920995ff)

Ну и последняя часть алгоритма, заключается в записи по каким-то смещениям содержимого регистров:

![image](https://github.com/user-attachments/assets/a94f5c04-06aa-48f5-98b2-00a574ccff75)


#### Резюме по статическому анализу: 
На данном этапе мы приблизительно поняли, как работает предложенная программа. На следующем шаге отладим программу и уже смоем узнать точные значения регистров 
и получить флаг.

#### Шаг 2. Отладка программы.

Для этого воспользуемся отладчиком edb. Запустить программу можно командой `edb --run ./keygenme`. 
#### Примечание:
Если программа не запускается, выдавая ошибку типа `./keygenme: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory`, то необходимо скачать openssl версии 1.1. Собрать библеотеку можно из исходников.

Решение: 
```bash
wget https://www.openssl.org/source/openssl-1.1.1o.tar.gz
tar -zxvf openssl-1.1.1o.tar.gz
cd openssl-1.1.1o
./config
make
make test
sudo make install
find / -name libssl.so.1.1
ln -s /usr/local/lib64/libssl.so.1.1  /usr/lib64/libssl.so.1.1
ln -s /usr/local/lib64/libssl.so.1.1  /usr/lib/libssl.so.1.1
find / -name libcrypto.so.1.1
ln -s /home/ubuntu/openssl-1.1.1o/libcrypto.so.1.1    /usr/lib64/libcrypto.so.1.1
ln -s /home/ubuntu/openssl-1.1.1o/libcrypto.so.1.1     /usr/lib/libcrypto.so.1.1
```

После нажатия клавиши F9 отладчик сразу перекинет нас на точку входа в программу.
![image](https://github.com/user-attachments/assets/da94e831-69d0-4771-933f-5ece4c614c09)
Расставим точки останова. Точки останова позволяют эффективно отлаживать программу, так как отладчик будет приостанавливать работу программу в нужных нам местах.
![image](https://github.com/user-attachments/assets/75ce513b-2333-4a63-81cb-3b4bb2000683)
В данном случае я поставил точку останова на инструкциях `call _fgets` и `call sub_1209`.
Ввводим строку, перепрыгиваем на следующую точку останова и нажатием клавиши F7 переходим в функцию sub_1209.



