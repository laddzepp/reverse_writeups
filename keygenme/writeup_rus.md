# Сайт: picoCTF
# Название: keygenme
# Автор: LT 'syreal' Jones
# Сложность: Hard

Решим задачу уровня сложности hard с picoCTF, хотя на мой лично взгяд данной задаче скорее подходит уровень сложности Medium. Приступим к решению.
Первым делом проводим статический анализ бинарного файла. 

#### Шаг 1. Статический анализ.

![image](https://github.com/user-attachments/assets/97f57ef9-e58a-4bb7-85d0-7fff6ce5185f)

В самом начале программы не происходит ничего сложного. Просто выводится приглашение ко вводу и реализуется ввод. Далее отрбабатывает загадочная функция 
`sub_1209`. После нее исполняется команда `test al, al` и выполняется проверка на установку флага ZF. Далее, в зависимости от ввода, переходим в одну из веток.
Посмотрим, что происходит в функции `sub_1209`.
![image](https://github.com/user-attachments/assets/3999dcce-a365-42b6-901f-2e33296b56d7) \
Сразу же бросаются в глаза символы представленные в виде hex. Напишем небольшой скрипт расшифровывающий строку.

```python
s1 = "7B4654436F636970"
s2 = "30795F676E317262"
s3 = "6B5F6E77305F7275"
s4 = "5F7933"
s5 = "7D"

s = s5 + s4 + s3 + s2 + s1
part_of_flag = bytearray.fromhex(s)
part_of_flag.reverse()
print(part_of_flag)
```

Увидим, следующую строчку `picoCTF{br1ng_y0ur_0wn_k3y_}`. Сразу же автор таска дает понять, что флаг неполный, поэтому продолжаем анализировать алгоритм. 
Далее генерируется хэш MD5 два раза. Данная функция берется из криптографической библеотеки `openssl`. Какие именно аргументы туда передаются, пока, что сказать трудно\
![image](https://github.com/user-attachments/assets/42870374-3a4a-4a63-b6ee-b1e68541da27)


Заглянем в документацию по openssl и найдем описание функции MD5. 

```c
unsigned char *MD5(const unsigned char *d, unsigned long n,
                 unsigned char *md);
```
Судя по описанию, функция принимает n байт, указатель на буфер d и указатель на буфер, где будет храниться md хэш.
Идем дальше. Остальные сведения получим на стадии отладки программы.

![image](https://github.com/user-attachments/assets/2882e03c-ada5-45be-9c02-c233bf1c64f3)

Видим цикл. Он логика внутри него отработает 15 раз. Следовательно  `var_C4` можно переименовать в `n`, а `var_C8` в `i`.
В блоке с логикой программы видим функцию `_sprintf`. Представим профиль данной функции ниже: 

```c
int sprintf(char *restrict str,
                   const char *restrict format, ...);
```

Данная функция является, как и `printf` вариадической. На месте троеточия она принимает любое кол-во аргументов. sprintf использутеся для записи некоторой строки в массив.
Получается, что в цикле, программа идет по некоторой строке и записывается символы в определенный буфер. Ровно такие же действия выполняются в цикле ниже

![image](https://github.com/user-attachments/assets/c35d6b86-7f3b-4d77-9f41-2a74920995ff)

Ну и последняя часть алгоритма, заключается в записи по каким-то смещениям содержимого регистров:

![image](https://github.com/user-attachments/assets/a94f5c04-06aa-48f5-98b2-00a574ccff75)


#### Резюме по статическому анализу: 
На данном этапе мы приблизетельно поняли, как работает предложенная программа. На следующем шаге отладим программу и уже смоем узнать точные значения регистров 
и получить флаг.

#### Шаг 2. Отладка программы.

Для этого воспользуемся отладчиком edb. Запустить программу можно командой `edb --run ./keygenme`. 


