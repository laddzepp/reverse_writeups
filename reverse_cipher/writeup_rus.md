
# Сайт: PicoCTF
# Задание: reverse_cipher
# Автор: Danny Tunitis 
# Сложность: Hard


Разберем задачу уровня сложности `Hard` с `.PicoCTF`. В задаче сказано разобрать работу бинарного файла и восстановить текоствый файл.
![image](https://github.com/user-attachments/assets/567553b0-0a19-4230-8df9-3fb86e7eadf6)
Традиционно начинаем статически анализировать программу :). 

#### Статический анализ.

![image](https://github.com/user-attachments/assets/d8fb592c-1745-41ad-9c45-0cbaa1539ab2)

Бинарный файл сразу же встречает нас открытием двух файлов `flag.txt` и `rev_this` с помощью функции `_fopen` профиль которой выглядит следующим 
образом: 
```c
FILE *fopen(const char *restrict pathname, const char *restrict mode);
```

В качестве параметров ей передается путь к файлу и режим с помощью которых мы открываем данные файлы. Вот некоторые из них: 
| Режим | Значение |
| :----- | :------- |
|   r    | На чтение |
|   w    | На запись | 
|  rw    | На чтение и запись |
|   a    | Открывает файл на запись и если его не существует, создает его, записывает данные в конец|

А возвращает функция указательна структуру `FILE`.
Исходя из этой таблицы посмотрим еще раз на бинарный файл и посмотрим каким образом открываются файлы. Файл `flag.txt` открывается только на чтение, а файл `rev_this` на запись.
В случае, если файлы открыть не удалось `_fopen` в обоих случаях вернет `NULL`. В таком случае, отработают следующие ветки программы:
![image](https://github.com/user-attachments/assets/a71776bf-f660-456c-b894-1dbc36523cbc)

Указатель, который вернется после открытия файла `flag.txt` хранится по смещению `[rbp+stream]` или `[rbp-0x18]`. Переименуем его в `[rbp+flag_file_ptr]`, а `[rbp+var_20]` в `[rbp+rev_file_ptr]` для того, чтобы нам было удобнее их различать в будущем. 

Перейдем к следующему блоку программы, который отвечает за считывание данных из файла `flag.txt`. 
![image](https://github.com/user-attachments/assets/fadc80ad-bbcd-4b83-9ac0-844a6ac82233) <br />
Осуществляется считывание с помощью функции `_fread` профиль которой выглядит вот таким образом:
```c
size_t fread(void ptr[restrict .size * .nmemb],
                    size_t size, size_t nmemb,
                    FILE *restrict stream);
```
`ptr` - указатель на буфер, куда будут записываться данные из потока, `size` - сколько данных считаем, `nmemb` - сколько весит каждый символ и последний `stream` - поток, то есть наш файл из которого будем считывать. Сама же функция возвращает кол-во считанных байт. Соответсвенно, из файла `flag.txt` мы считаем 24 байта и первый байт считанного буфера будет храниться по адресу `[rbp+ptr]`.
В зависимости от результата работы функции, перейдем в одну из двух веток. На выход с кодом 0: 
![image](https://github.com/user-attachments/assets/9c049ecd-c6c6-4cb1-9481-ae07cf96fecf)

Или в цикл, который запишет первые восемь символов из файла `flag.txt`.
![image](https://github.com/user-attachments/assets/f66e308b-be0e-47af-a2a6-473c696c5aea)



