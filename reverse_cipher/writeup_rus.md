![image](https://github.com/user-attachments/assets/f14e0d27-07a7-4a25-a411-5c3810106ab7)
# Сайт: PicoCTF
# Задание: reverse_cipher
# Автор: Danny Tunitis 
# Сложность: Hard


Разберем задачу уровня сложности `Hard` с `.PicoCTF`. В задаче сказано разобрать работу бинарного файла и восстановить текоствый файл.
![image](https://github.com/user-attachments/assets/567553b0-0a19-4230-8df9-3fb86e7eadf6)
Традиционно начинаем статически анализировать программу :). 

#### Статический анализ.

![image](https://github.com/user-attachments/assets/d8fb592c-1745-41ad-9c45-0cbaa1539ab2)

Бинарный файл сразу же встречает нас открытием двух файлов `flag.txt` и `rev_this` с помощью функции `_fopen` профиль которой выглядит следующим 
образом: 
```c
FILE *fopen(const char *restrict pathname, const char *restrict mode);
```

В качестве параметров ей передается путь к файлу и режим с помощью которых мы открываем данные файлы. Вот некоторые из них: 
| Режим | Значение |
| :----- | :------- |
|   r    | На чтение |
|   w    | На запись | 
|  rw    | На чтение и запись |
|   a    | Открывает файл на запись и если его не существует, создает его, записывает данные в конец|

А возвращает функция указательна структуру `FILE`.
Исходя из этой таблицы посмотрим еще раз на бинарный файл и посмотрим каким образом открываются файлы. Файл `flag.txt` открывается только на чтение, а файл `rev_this` на запись.
В случае, если файлы открыть не удалось `_fopen` в обоих случаях вернет `NULL`. В таком случае, отработают следующие ветки программы:
![image](https://github.com/user-attachments/assets/a71776bf-f660-456c-b894-1dbc36523cbc)

Указатель, который вернется после открытия файла `flag.txt` хранится по смещению `[rbp+stream]` или `[rbp-0x18]`. Переименуем его в `[rbp+flag_file_ptr]`, а `[rbp+var_20]` в `[rbp+rev_file_ptr]` для того, чтобы нам было удобнее их различать в будущем. 

Перейдем к следующему блоку программы, который отвечает за считывание данных из файла `flag.txt`. 
![image](https://github.com/user-attachments/assets/fadc80ad-bbcd-4b83-9ac0-844a6ac82233) <br />
Осуществляется считывание с помощью функции `_fread` профиль которой выглядит вот таким образом:
```c
size_t fread(void ptr[restrict .size * .nmemb],
                    size_t size, size_t nmemb,
                    FILE *restrict stream);
```
`ptr` - указатель на буфер, куда будут записываться данные из потока, `size` - сколько данных считаем, `nmemb` - сколько весит каждый символ и последний `stream` - поток, в нашем случае - файл из которого будем считывать. Сама же функция возвращает кол-во считанных байт. Соответсвенно, из файла `flag.txt` мы считаем 24 байта и первый байт считанного буфера будет храниться по адресу `[rbp+ptr]`.
В зависимости от результата работы функции, перейдем в одну из двух веток. На выход с кодом 0: 
![image](https://github.com/user-attachments/assets/9c049ecd-c6c6-4cb1-9481-ae07cf96fecf)

Или в цикл, который запишет первые восемь символов из файла `flag.txt` в файл `rev_this`.
![image](https://github.com/user-attachments/assets/f66e308b-be0e-47af-a2a6-473c696c5aea)

Профиль функции `fputc` выглядит следующим образом. 
```c
int fputc(int c, FILE *stream);
```
Данная функция записывает символ в некоторый поток, который является нашим файлом. `[rbp+var_1]` - это символ, который будем записывать в файл. Переименуем его в `sym` и перейдем 
к следующем блоку: <br />
![image](https://github.com/user-attachments/assets/9926a0d5-6934-4179-aca2-d851e5189938) <br />
Здесь инициализируется новый цикл, который отработает с 8 по 22 символ, внтури него тоже есть некоторая логика: <br />
![image](https://github.com/user-attachments/assets/42c37cd9-2259-41d9-a7ac-4425fdfb9fb1) <br />
В регистр `eax` кладется длина строки. Длина проверяется на чётность с помощью побитовой операции AND. А команда `test` будет влиять на флаг `ZF` и переводить в зависимости 
от его значения в определенную ветку. Если длина строки четная, все биты при команде `test` сбросились и флаг `ZF` установился в значение 1 <br />
![image](https://github.com/user-attachments/assets/dd6cf434-c9ed-4418-a66b-074fc7349692) <br />
То есть к ascii-коду прибавляем 5, иначе отнимаем 2: <br />
![image](https://github.com/user-attachments/assets/9d9eca1f-859a-4f4f-acd2-3a99ec187db4) <br />
И результат будет записываться в файл `rev_this`: <br />
![image](https://github.com/user-attachments/assets/4f2bffa5-cc4a-413f-a485-1a82b961c4ed) <br />

На последок, мы закрываем все потоки и выходим из программы: <br >
![image](https://github.com/user-attachments/assets/cea0306b-3a4a-4de8-9bc9-a806203f7e8f) <br />

На этом статический анализ заканчивается и мы приступаем к решению.

#### Решение.

Решение произведем с помощью языка программирования Python.






